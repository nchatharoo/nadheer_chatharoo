<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>MVVM - Nadheer Chatharoo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="/nadheer_chatharoo/style.css">
</head>
<body>
<header>
  <div class="header-content">
    <img class="avatar" src="/images/avatar.jpg" alt="avatar" />
    <div>
      <h1>Nadheer Chatharoo</h1>
      <p>D√©veloppement iOS et plus...</p>
    </div>
    <div class="social">
      <a href="https://github.com/nchatharoo" target="_blank">üêô</a>
      <a href="https://www.linkedin.com/in/nchatharoo" target="_blank">üíº</a>
      <a href="https://twitter.com/NadheerC" target="_blank">üê¶</a>
    </div>
  </div>
</header>
<main>
  
<article class="post-full">
  <div class="post-header">
    <h1>MVVM</h1>
    <img src="&#x2F;images&#x2F;cover_mvvm.jpg" alt="MVVM">
  </div>
  <div class="post-body">
    <h2>Un mod√®le de conception d'interface utilisateur</h2>
<p>MVVM est un mod√®le architectural d'interface utilisateur, et signifie Model-View-ViewModel. MVVM est une variante du MVC cr√©√©e par Microsoft, qui vise √† minimiser le code standard n√©cessaire pour synchroniser les √©v√©nements de la Vue et les mises √† jour du Mod√®le que g√®rent les Contr√¥leurs.</p>
<p>Gr√¢ce √† un composant ViewModel, la solution MVVM de Microsoft connecte de mani√®re transparente les √©v√©nements de la Vue avec les mises √† jour du Mod√®le.</p>
<p>Les d√©veloppeurs d√©clarent les liaisons du ViewModel avec les d√©clarations de la Vue en XAML, et le framework g√®re automatiquement les liaisons √† l'ex√©cution, selon le syst√®me graphique .NET de Microsoft.</p>
<p>Comme la plupart des plateformes n'offrent pas le c√¢blage automatique que propose le syst√®me graphique .NET, MVVM est souvent connu sous le nom de Model-View-Binder en dehors des syst√®mes Microsoft.</p>
<p>Dans UIKit, par exemple, il n'y a pas de m√©canisme pour connecter automatiquement un ViewModel √† une Vue, donc le d√©veloppeur doit impl√©menter les composants Binder. Il est courant d'utiliser des frameworks comme RxSwift ou Combine (ou des closures !) pour faciliter les connexions entre la Vue et le ViewModel.</p>
<h2>Comparaison entre MVC et MVVM :</h2>
<p><img src="/images/2021-12-29-MVC-MVVM.png" alt="MVC-MVVM" /></p>
<p>La seule diff√©rence entre les structures MVC et MVVM est qu'un ViewModel ne contient pas de r√©f√©rence √† la Vue comme le fait le Contr√¥leur dans MVC.</p>
<p>Pour rendre √† la fois la Vue et le ViewModel plus r√©utilisables, ils ne devraient pas d√©pendre directement l'un de l'autre. Ils devraient pouvoir communiquer de mani√®re indirecte gr√¢ce √† un m√©canisme de liaison.</p>
<p>Les UIViewController sont des candidats id√©aux pour agir comme Binders dans UIKit, reliant la Vue au ViewModel. C'est parce que pour afficher des vues √† l'√©cran dans UIKit, votre application doit avoir au moins un UIViewController.</p>
<p>Comme les UIViewController ont d√©j√† une r√©f√©rence √† leurs Vues correspondantes, ils sont un excellent endroit pour injecter et lier le ViewModel avec la Vue.</p>
<p><img src="/images/2021-12-29-MVVM-Binder.png" alt="MVVM-Binder" /></p>
<p>Cependant, dans UIKit, MVVM ne r√©duira pas beaucoup le code standard car il n'y a pas de liaison automatique. N√©anmoins, les ViewModels sont une bonne id√©e pour cr√©er une logique r√©utilisable entre les composants UI et core et une meilleure s√©paration architecturale. Il est recommand√© que les ViewModels soient ind√©pendants de la plateforme et du framework afin que nous puissions les r√©utiliser sur plusieurs plateformes.</p>
<h2>MVVM en pratique :</h2>
<p>Imaginez un simple ViewController :</p>
<pre><code class="language-swift">final class ViewController: NSObject {

  private(set) lazy var view: UIRefreshControl = {
      let view = UIRefreshControl()
        view.addTarget(self, action: #selector(refresh), for: .valueChanged)
        return view
  }()

  private let loader: ModelLoader

  var onRefresh: (([Model]) -&gt; Void)?

  init(loader: ModelLoader) {
        self.loader = loader
  }

  @objc func refresh() {
        view.beginRefreshing()
        loader.load { [weak self] result in
                if let model = try? result.get() {
                self?.onRefresh?(model)
            }
            self?.view.endRefreshing()
        }
    }
}
</code></pre>
<p>Nous pouvons voir que le ViewController communique avec le ModelLoader, g√®re √©galement l'√©tat de chargement du mod√®le avec la variable <code>onRefresh</code> et cr√©e et configure un UIRefreshControl.</p>
<p>L'objectif est de d√©placer certaines responsabilit√©s du ViewController vers un ViewModel.</p>
<p>Il existe deux fa√ßons courantes de cr√©er un ViewModel, avec √©tat (stateful) et sans √©tat (stateless).</p>
<h2>Version avec √©tat :</h2>
<p>Ainsi, le ViewModel peut avoir plusieurs types d'√©tats (chargement, en attente, etc...) et nous notifions l'observateur de tout changement d'√©tat avec une simple closure (<code>onChange</code>).
Nous d√©finissons √©galement les transitions d'√©tat en d√©finissant la <code>var state</code> dans la m√©thode <code>loadModel()</code>. Comme l'√©tat est priv√©, nous exposons des accesseurs pour l'√©tat actuel du ViewModel avec <code>isLoading</code> (un switch est suffisant dans ce cas) et une var calcul√©e pour acc√©der au mod√®le, s'il est charg√©, nous retournons le mod√®le sinon nous retournons nil.</p>
<pre><code class="language-swift">final class ViewModel {
    private let loader: ModelLoader
    
    init(loader: ModelLoader) {
        self.loader = loader
    }
    
    private enum State {
        case loading
        case pending
        case loaded([Model])
        case failure
    }
    
    private var state = State.pending {
        didSet { onChange?(self) }
    }
    
    var onChange: ((ViewModel) -&gt; Void)?
    
    var isLoading: Bool {
        switch state {
            case .loading: return true
            case .pending, .loaded, .failure: return false
        }
    }
    
    var model: [Model]? {
        switch state {
        case .loaded(let model):
            return model
        case .loading, .pending, .failure:
            return nil
        }
    }
    
    func loadModel() {
        state = .loading
        loader.load { [weak self] result in
            if let model = try? result.get() {
                self?.state = .loaded(model)
            } else {
                self?.state = .failed
            }
        }
    }
}
</code></pre>
<p>C'est tout ce dont nous avons besoin dans le ViewModel, mais qu'en est-il du ViewController ?</p>
<p>Premi√®rement, nous rempla√ßons la r√©f√©rence <code>ModelLoader</code> par une propri√©t√© <code>viewModel</code>.</p>
<p>Deuxi√®mement, dans la fonction <code>refresh</code>, nous d√©finissons le callback <code>onChange</code> pour obtenir un <code>viewModel</code> et sa propri√©t√© <code>isLoading</code> pour d√©terminer si nous devons rafra√Æchir ou non.</p>
<p>Troisi√®mement, nous devons voir si nous avons un mod√®le dans le ViewModel, et le passer avec la closure <code>onRefresh</code>.</p>
<p>Et enfin, nous disons au ViewModel de charger le mod√®le</p>
<pre><code class="language-swift">final class ViewController: NSObject {
    private(set) lazy var view: UIRefreshControl = {
        let view = UIRefreshControl()
        view.addTarget(self, action: #selector(refresh), for: .valueChanged)
        return view
    }()

    private let viewModel: ViewModel
    
    var onRefresh: (([Model]) -&gt; Void)?
    
    init(viewModel: ViewModel) {
        self.viewModel = viewModel
    }
    
    @objc func refresh() {
        viewModel.onChange = { [weak self] viewModel in
            if viewModel.isLoading {
                self?.view.beginRefreshing()
            } else {
                self?.view.endRefreshing()
            }
            
            if let model = viewModel.model {
                self?.onRefresh?(model)
            }
        }
        viewModel.loadModel()
    }
}
</code></pre>
<p>Ainsi, la closure <code>onChange</code> est la logique de liaison entre notre ViewModel et la Vue, se produisant dans le ViewController. Nous pouvons m√™me envelopper la closure dans une fonction <code>binded</code>, de sorte que la Vue soit un UIRefreshControl li√© :</p>
<pre><code class="language-swift">private(set) lazy var view = binded(UIRefreshControl()) 

private func binded(_ view: UIRefreshControl) -&gt; UIRefreshControl {
      viewModel.onChange = { [weak self] viewModel in
          if viewModel.isLoading {
              self?.view.beginRefreshing()
          } else {
              self?.view.endRefreshing()
          }

          if let model = viewModel.model {
              self?.onRefresh?(model)
          }
      }
      view.addTarget(self, action: #selector(refresh), for: .valueChanged)
      return view
}
</code></pre>
<p>Remarquez les derni√®res lignes de code, nous ne d√©finissons pas le <code>viewModel</code> comme une action cible avec la vue. C'est parce que le mod√®le d'action cible force l'instance √† √™tre un NSObject, et se conformer √† NSObject est une exigence d'UIKit. Les view models devraient √™tre agnostiques de la plateforme, en faisant du ViewModel une sous-classe de NSObject, nous divulguons des d√©tails d'impl√©mentation juste pour satisfaire UIKit.
En gardant <code>self</code>, c'est le ViewController qui transmet le message au ViewModel.</p>
<p>Il y a un autre code suspect, le <code>onRefresh</code> fait r√©f√©rence au Model ! Nous pouvons d√©placer cette logique vers le ViewModel, car le ViewController ne fait que passer le <code>model</code>, il ne fait rien avec.</p>
<pre><code class="language-swift">final class ViewController: NSObject {
    private(set) lazy var view = binded(UIRefreshControl()) 
    
    private let viewModel: ViewModel
        
    init(viewModel: ViewModel) {
        self.viewModel = viewModel
    }
    
    @objc func refresh() {
        viewModel.loadModel()
    }
    
    private func binded(_ view: UIRefreshControl) -&gt; UIRefreshControl {
        viewModel.onChange = { [weak self] viewModel in
            if viewModel.isLoading {
                self?.view.beginRefreshing()
            } else {
                self?.view.endRefreshing()
            }
        }
        view.addTarget(self, action: #selector(refresh), for: .valueChanged)
    }
}
</code></pre>
<p>Maintenant, notre ViewController ne g√®re aucun √©tat, il lie la Vue au ViewModel. Toute la gestion de l'√©tat vit maintenant dans une version avec √©tat du ViewModel.</p>
<p>Nous n'avons pas besoin de conserver l'√©tat du mod√®le, en le transmettant simplement √† la closure <code>onRefresh</code>, nous pouvons nous d√©barrasser de
<code>self?.state = .loaded(model)</code>
Nous devons toujours mettre √† jour la Vue, donc le nouvel √©tat est <code>.pending</code>. Nous nous retrouvons donc avec deux √©tats, soit chargement soit en attente.
Et parce que nous n'avons que deux √©tats, un simple bool√©en <code>isLoading</code> est suffisant, nous pouvons supprimer l'enum <code>State</code> et la var calcul√©e <code>model</code>.</p>
<pre><code class="language-swift">final class ViewModel {
    private let loader: ModelLoader
    
    init(loader: ModelLoader) {
        self.loader = loader
    }
    
    var onChange: ((ViewModel) -&gt; Void)?
    var onRefresh: (([Model]) -&gt; Void)?

    private(set) var isLoading: Bool = false {
        didSet { onChange?(self) }
    }
    
    func loadModel() {
        isLoading = true
        loader.load { [weak self] result in
            if let model = try? result.get() {
                self?.onRefresh?(model)
            }
        isLoading = false
        }
    }
}
</code></pre>
<p>Transformons le ViewModel en une version sans √©tat.</p>
<h2>Version sans √©tat :</h2>
<p>Nous pouvons voir que le ViewModel conserve l'√©tat avec le bool√©en <code>isLoading</code>, pour obtenir un √©tat transitoire, nous pouvons utiliser une closure observateur pour chaque √©tat.</p>
<pre><code class="language-swift">final class ViewModel {
    private let loader: ModelLoader
    
    init(loader: ModelLoader) {
        self.loader = loader
    }
  
    var onRefresh: (([Model]) -&gt; Void)?
    var onLoadingStateChange: ((Bool) -&gt; Void)?
        
    func loadModel() {
        onLoadingStateChange?(true)
        loader.load { [weak self] result in
            if let model = try? result.get() {
                self?.onRefresh?(model)
            }
            onLoadingStateChange?(false)
        }
    }
}
</code></pre>
<p>En ayant un <code>onLoadingStateChange</code>, nous pouvons passer la transition d'√©tat dans la closure. Et dans le ViewController, nous avons maintenant ceci :</p>
<pre><code class="language-swift">final class ViewController: NSObject {
    private(set) lazy var view = binded(UIRefreshControl()) 
    
    private let viewModel: ViewModel
        
    init(viewModel: ViewModel) {
        self.viewModel = viewModel
    }
    
    @objc func refresh() {
        viewModel.loadModel()
    }
    
    private func binded(_ view: UIRefreshControl) -&gt; UIRefreshControl {
        viewModel.onLoadingStateChange = { [weak view] isLoading in
            if isLoading {
                view?.beginRefreshing()
            } else {
                view?.endRefreshing()
            }
        }
        view.addTarget(self, action: #selector(refresh), for: .valueChanged)
    }
}
</code></pre>
<p>Dans la fonction <code>binded</code>, nous d√©finissons le <code>onLoadingStateChange</code> en passant un bool√©en, et en affaiblissant la vue, puisque nous n'avons pas besoin d'une r√©f√©rence √† self.</p>
<h2>Bonus : G√©n√©riques et typealias</h2>
<p>Dans le ViewModel, nous pouvons utiliser des G√©n√©riques et des typealias, de cette fa√ßon nous ne laissons pas de place aux suppositions.</p>
<pre><code class="language-swift">final class ViewModel {
    typealias Observer&lt;T&gt; = (T) -&gt; Void
    
    private let loader: ModelLoader
    
    init(loader: ModelLoader) {
        self.loader = loader
    }
    
    var onRefresh: Observer&lt;Model&gt;?
    var onLoadingStateChange: Observer&lt;Bool&gt;?
        
    func loadModel() {
        onLoadingStateChange?(true)
        loader.load { [weak self] result in
            if let model = try? result.get() {
                self?.onRefresh?(model)
            }
            onLoadingStateChange?(false)
        }
    }
}
</code></pre>

  </div>
</article>

</main>
<footer>
  <p>¬© 2024 - Fais avec Rust</p>
</footer>
</body>
</html>