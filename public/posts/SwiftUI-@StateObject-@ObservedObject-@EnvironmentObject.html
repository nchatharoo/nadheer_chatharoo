<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>SwiftUI et la gestion d&#x27;√©tat - Nadheer Chatharoo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="/style.css">
</head>
<body>
<header>
  <div class="header-content">
    <img class="avatar" src="/images/avatar.jpg" alt="avatar" />
    <div>
      <h1>Nadheer Chatharoo</h1>
      <p>D√©veloppement iOS, SwiftUI et plus...</p>
    </div>
    <div class="social">
      <a href="https://github.com/nchatharoo" target="_blank">üêô</a>
      <a href="https://www.linkedin.com/in/nchatharoo" target="_blank">üíº</a>
      <a href="https://twitter.com/NadheerC" target="_blank">üê¶</a>
    </div>
  </div>
</header>
<main>
  
<article class="post-full">
  <div class="post-header">
    <h1>SwiftUI et la gestion d&#x27;√©tat</h1>
    <img src="&#x2F;images&#x2F;cover_stateobject.jpg" alt="SwiftUI et la gestion d&#x27;√©tat">
  </div>
  <div class="post-body">
    <h1>@StateObject, @ObservedObject et @EnvironmentObject</h1>
<p>Alors que faire si nous voulons lier notre vue √† un objet de classe ? Nous pouvons utiliser @StateObject, @ObservedObject, ou @EnvironmentObject pour g√©rer l'√©tat, mais nous devons faire en sorte que notre classe se conforme au protocole ObservableObject. Comme le dit la documentation : Un type d'objet avec un √©diteur qui √©met avant que l'objet n'ait chang√©.</p>
<p>Cela signifie simplement que notre classe agit comme un √©diteur et notifie ses abonn√©s des changements pour les propri√©t√©s marqu√©es avec @Published.</p>
<p>La classe se conforme √† ObservableObject, marquons une propri√©t√© comme @Published et connectons-la √† une vue.</p>
<h2>@StateObject</h2>
<p>Lors de l'utilisation de @StateObject, SwiftUI cr√©era l'objet une seule fois. M√™me si la vue enti√®re doit √™tre re-rendue.</p>
<p><img src="/images/tIV0Mm9XZexOIa9HMbiSbPAdVOg.png" alt="" /></p>
<p>Dans le code ci-dessus, lorsque l'utilisateur appuie sur le bouton, tous les √©l√©ments changent de couleur. L'objet Counter est cr√©√© une fois, et garde sa valeur peu importe le nombre de fois o√π la couleur est chang√©e (re-rendue). Lorsque notre vue est propri√©taire de l'objet (c'est-√†-dire qu'elle le cr√©e), nous devons utiliser @StateObject.</p>
<p><img src="/images/AJ6v5gz9oTI1msRKB4y8MgWjD6E.mp4" alt="" /></p>
<h2>@ObservedObject</h2>
<p>Au contraire, lors de l'instanciation d'un @ObservedObject, l'objet sera re-rendu chaque fois que la vue est re-rendue.</p>
<p><img src="/images/gmyoY1u6g35iD6yvTjfzH29sOs.png" alt="" /></p>
<p>Nous pouvons voir que le Counter est r√©initialis√© √† 0 √† chaque tapotement, car ContentView ne poss√®de pas StateStepper ou Counter, elle ne conna√Æt pas leur √©tat, donc ils sont re-rendus.</p>
<p><img src="images/YbpAvlH9PUXcAdGsu8g2ftCgPaE.mp4" alt="" /></p>
<h2>@EnvironmentObject</h2>
<p>Parfois, nous aurons des donn√©es qui n'ont pas besoin d'√™tre partag√©es avec toutes les vues de notre application, pensez au nom d'utilisateur ou √† l'avatar. Donc pour √©viter le couplage √©troit entre les vues, Apple fournit le wrapper @EnvironmentObject.</p>
<p><img src="/images/94JcDYluiJkHwt1gkBLZcafRjv0.png" alt="" /></p>
<p>Dans le code ci-dessus, nous partageons avec la vue UserProfileScreen le nom de l'utilisateur en utilisant @EnvironmentObject et le modificateur .environmentObject, sans polluer la vue SettingsScreen avec une d√©pendance dont elle n'a pas besoin. M√™me si @EnvironmentObject est un outil puissant, il y a un probl√®me si nous ne sommes pas prudents : SwiftUI ne sait pas si l'objet inject√© est instanci√©, ce qui signifie que si notre objet est nul, l'application plantera √† l'ex√©cution.</p>

  </div>
</article>

</main>
<footer>
  <p>¬© 2024 - Fais avec Rust</p>
</footer>
</body>
</html>