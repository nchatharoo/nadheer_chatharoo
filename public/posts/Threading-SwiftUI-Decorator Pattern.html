<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Threading dans SwiftUI avec le Pattern D√©corateur - Nadheer Chatharoo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="/style.css">
</head>
<body>
<header>
  <div class="header-content">
    <img class="avatar" src="/images/avatar.jpg" alt="avatar" />
    <div>
      <h1>Nadheer Chatharoo</h1>
      <p>D√©veloppement iOS et plus...</p>
    </div>
    <div class="social">
      <a href="https://github.com/nchatharoo" target="_blank">üêô</a>
      <a href="https://www.linkedin.com/in/nchatharoo" target="_blank">üíº</a>
      <a href="https://twitter.com/NadheerC" target="_blank">üê¶</a>
    </div>
  </div>
</header>
<main>
  
<article class="post-full">
  <div class="post-header">
    <h1>Threading dans SwiftUI avec le Pattern D√©corateur</h1>
    <img src="&#x2F;images&#x2F;cover_decorator.jpg" alt="Threading dans SwiftUI avec le Pattern D√©corateur">
  </div>
  <div class="post-body">
    <h1>D√©couplage des d√©tails de threading dans SwiftUI avec le Pattern D√©corateur</h1>
<p>Dans cet article, nous allons voir comment le Pattern D√©corateur peut aider les vues SwiftUI √† devenir plus propres et plus centr√©es sur leur objectif principal en supprimant les d√©tails de threading. Voyons comment cela fonctionne. Le Pattern D√©corateur est un mod√®le de conception structurel qui vous permet d'ajouter une nouvelle fonctionnalit√© √† un objet sans changer sa structure fondamentale. Il implique un ensemble de classes d√©corateur qui enveloppent des composants concrets. Les classes d√©corateur refl√®tent le type des composants qu'elles d√©corent (elles ont la m√™me interface) mais ajoutent ou remplacent un comportement.</p>
<p>Cr√©ons un exemple simple :</p>
<p><img src="/images/ouHhzvPJlaDX5erTqOA8J3EQxk.png" alt="" /></p>
<p>Cr√©ez la vue et utilisez la fonction fetchData :</p>
<p><img src="/images/y3sAQ2ItHQQ4XLYD7ME5Dd5uCt8.png" alt="" /></p>
<p>Remarquez le DispatchQueue utilis√© ici, il est n√©cessaire car DispatchQueue.main.async est utilis√© pour s'assurer que la closure mettant √† jour la propri√©t√© d'√©tat data est ex√©cut√©e sur le thread principal.</p>
<p>Lorsque fetchData se termine, elle appelle la closure fournie avec les nouvelles donn√©es. La closure met ensuite √† jour la propri√©t√© data, ce qui d√©clenche un nouveau rendu de la vue Text. Comme les vues SwiftUI sont mises √† jour et dessin√©es sur le thread principal, tout changement de l'interface utilisateur (comme la mise √† jour de la propri√©t√© data) doit √™tre effectu√© depuis le thread principal pour √©viter les conditions de course potentielles ou les incoh√©rences de l'interface utilisateur. Mais maintenant, la ContentView r√©cup√®re les donn√©es onAppear et met √† jour son √©tat, mais les d√©tails de threading sont m√©lang√©s avec le code de la vue. C'est l√† que le Pattern D√©corateur vient √† la rescousse.</p>
<p>D√©finissons d'abord un protocole d√©corateur :</p>
<p><img src="/images/rLMV0bpZjwAJNOgMdbuBleDEcM.png" alt="" /></p>
<p>Et cr√©ons un d√©corateur :
<img src="/images/TbfRz8NH2b7antsiwZSihRCHiE.png" alt="" /></p>
<p>Ce d√©corateur accepte une closure de contenu et une closure onAppear. Il s'assure que la closure est ex√©cut√©e sur le thread principal. Nous pouvons maintenant appliquer notre MainThreadDecorator √† la vue Text :</p>
<p><img src="/images/sqZDUt3ObWv7Jksg6f8ME9Oaug.png" alt="" /></p>

  </div>
</article>

</main>
<footer>
  <p>¬© 2024 - Fais avec Rust</p>
</footer>
</body>
</html>